[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "wfdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wfdb",
        "description": "wfdb",
        "detail": "wfdb",
        "documentation": {}
    },
    {
        "label": "layers",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "regularizers",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "bandpass_filter",
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "isExtraImport": true,
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "notch_filter",
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "isExtraImport": true,
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "remove_baseline",
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "isExtraImport": true,
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "extract_heartbeats",
        "importPath": "preProcessing.Segment",
        "description": "preProcessing.Segment",
        "isExtraImport": true,
        "detail": "preProcessing.Segment",
        "documentation": {}
    },
    {
        "label": "balance_classes",
        "importPath": "preProcessing.ClassBalancing",
        "description": "preProcessing.ClassBalancing",
        "isExtraImport": true,
        "detail": "preProcessing.ClassBalancing",
        "documentation": {}
    },
    {
        "label": "normalize_beats",
        "importPath": "preProcessing.Normalization",
        "description": "preProcessing.Normalization",
        "isExtraImport": true,
        "detail": "preProcessing.Normalization",
        "documentation": {}
    },
    {
        "label": "load_ecg",
        "importPath": "preProcessing.Load",
        "description": "preProcessing.Load",
        "isExtraImport": true,
        "detail": "preProcessing.Load",
        "documentation": {}
    },
    {
        "label": "create_labels",
        "importPath": "preProcessing.Labels",
        "description": "preProcessing.Labels",
        "isExtraImport": true,
        "detail": "preProcessing.Labels",
        "documentation": {}
    },
    {
        "label": "train_model",
        "importPath": "models.Train",
        "description": "models.Train",
        "isExtraImport": true,
        "detail": "models.Train",
        "documentation": {}
    },
    {
        "label": "evaluate_model",
        "importPath": "models.Evaluate",
        "description": "models.Evaluate",
        "isExtraImport": true,
        "detail": "models.Evaluate",
        "documentation": {}
    },
    {
        "label": "plot_metrics",
        "importPath": "models.Evaluate",
        "description": "models.Evaluate",
        "isExtraImport": true,
        "detail": "models.Evaluate",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "SMOTE",
        "importPath": "imblearn.over_sampling",
        "description": "imblearn.over_sampling",
        "isExtraImport": true,
        "detail": "imblearn.over_sampling",
        "documentation": {}
    },
    {
        "label": "RandomOverSampler",
        "importPath": "imblearn.over_sampling",
        "description": "imblearn.over_sampling",
        "isExtraImport": true,
        "detail": "imblearn.over_sampling",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "butter",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "filtfilt",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "iirnotch",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "bandpass_filter",
        "importPath": "Denoise",
        "description": "Denoise",
        "isExtraImport": true,
        "detail": "Denoise",
        "documentation": {}
    },
    {
        "label": "notch_filter",
        "importPath": "Denoise",
        "description": "Denoise",
        "isExtraImport": true,
        "detail": "Denoise",
        "documentation": {}
    },
    {
        "label": "remove_baseline",
        "importPath": "Denoise",
        "description": "Denoise",
        "isExtraImport": true,
        "detail": "Denoise",
        "documentation": {}
    },
    {
        "label": "extract_heartbeats",
        "importPath": "Segment",
        "description": "Segment",
        "isExtraImport": true,
        "detail": "Segment",
        "documentation": {}
    },
    {
        "label": "balance_classes",
        "importPath": "ClassBalancing",
        "description": "ClassBalancing",
        "isExtraImport": true,
        "detail": "ClassBalancing",
        "documentation": {}
    },
    {
        "label": "normalize_beats",
        "importPath": "Normalization",
        "description": "Normalization",
        "isExtraImport": true,
        "detail": "Normalization",
        "documentation": {}
    },
    {
        "label": "load_ecg",
        "importPath": "Load",
        "description": "Load",
        "isExtraImport": true,
        "detail": "Load",
        "documentation": {}
    },
    {
        "label": "create_labels",
        "importPath": "Labels",
        "description": "Labels",
        "isExtraImport": true,
        "detail": "Labels",
        "documentation": {}
    },
    {
        "label": "neurokit2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "neurokit2",
        "description": "neurokit2",
        "detail": "neurokit2",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "data.DownloadData",
        "description": "data.DownloadData",
        "peekOfCode": "DATA_DIR = \"data/mitdb\"\nif os.path.isdir(DATA_DIR):\n    print(\"Dataset already exists.\")\nelse : \n    os.makedirs(DATA_DIR, exist_ok=True)\n    print(\"Downloading MIT-BIH data set ......\")\n    wfdb.dl_database('mitdb', DATA_DIR)\n    print(\"Download ended ! Now you you can work with pre-processing\")",
        "detail": "data.DownloadData",
        "documentation": {}
    },
    {
        "label": "build_cnn",
        "kind": 2,
        "importPath": "models.CnnModel",
        "description": "models.CnnModel",
        "peekOfCode": "def build_cnn(input_shape, num_classes=5):\n    model = models.Sequential([\n        layers.Input(shape=input_shape),\n        layers.Conv1D(64, 15, activation='relu', padding='same'), \n        layers.BatchNormalization(),\n        layers.MaxPooling1D(2),\n        layers.Conv1D(128, 7, activation='relu', padding='same'),\n        layers.BatchNormalization(),\n        layers.MaxPooling1D(2),\n        layers.Conv1D(256, 5, activation='relu', padding='same'),",
        "detail": "models.CnnModel",
        "documentation": {}
    },
    {
        "label": "plot_metrics",
        "kind": 2,
        "importPath": "models.Evaluate",
        "description": "models.Evaluate",
        "peekOfCode": "def plot_metrics(history):\n    plt.figure(figsize=(12, 4))\n    plt.subplot(1, 2, 1)\n    plt.plot(history.history['accuracy'], label='Train')\n    plt.plot(history.history['val_accuracy'], label='Validation')\n    plt.title('Model Accuracy')\n    plt.ylabel('Accuracy')\n    plt.xlabel('Epoch')\n    plt.legend()\n    plt.subplot(1, 2, 2)",
        "detail": "models.Evaluate",
        "documentation": {}
    },
    {
        "label": "evaluate_model",
        "kind": 2,
        "importPath": "models.Evaluate",
        "description": "models.Evaluate",
        "peekOfCode": "def evaluate_model(model, X_test, y_test):\n    y_pred = np.argmax(model.predict(X_test), axis=1)\n    print(classification_report(y_test, y_pred))\n    cm = confusion_matrix(y_test, y_pred)\n    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\n    plt.xlabel('Predicted')\n    plt.ylabel('True')\n    plt.show()",
        "detail": "models.Evaluate",
        "documentation": {}
    },
    {
        "label": "process_record",
        "kind": 2,
        "importPath": "models.MainPipeLine",
        "description": "models.MainPipeLine",
        "peekOfCode": "def process_record(record_id, data_dir):\n    signal, rpeaks, fs, ann = load_ecg(record_id, data_dir)\n    print(f\"Total annotations: {len(ann.sample)}\")\n    signal = bandpass_filter(signal, fs)\n    signal = notch_filter(signal, fs)\n    signal = remove_baseline(signal, fs)\n    beats, valid_rpeaks = extract_heartbeats(signal, fs, ann.sample)\n    print(f\"Extracted {len(beats)} valid beats\")\n    beats = normalize_beats(beats)\n    labels = create_labels(valid_rpeaks, ann)",
        "detail": "models.MainPipeLine",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "kind": 2,
        "importPath": "models.MainPipeLine",
        "description": "models.MainPipeLine",
        "peekOfCode": "def load_dataset(record_ids, data_dir):\n    all_beats = []\n    all_labels = []\n    for record_id in record_ids:\n        print(f\"Processing record {record_id}...\")\n        X, y = process_record(str(record_id), data_dir)\n        all_beats.append(X)\n        all_labels.append(y)\n    X_all = np.concatenate(all_beats, axis=0)\n    y_all = np.concatenate(all_labels, axis=0)",
        "detail": "models.MainPipeLine",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "models.Train",
        "description": "models.Train",
        "peekOfCode": "def train_model(X_train, y_train, X_val, y_val):\n    model = build_cnn(input_shape=X_train.shape[1:])\n    callbacks = [\n        tf.keras.callbacks.EarlyStopping(patience=5, restore_best_weights=True)\n    ]\n    history = model.fit(\n        X_train, y_train,\n        validation_data=(X_val, y_val),\n        epochs=50,\n        batch_size=32,",
        "detail": "models.Train",
        "documentation": {}
    },
    {
        "label": "balance_classes",
        "kind": 2,
        "importPath": "preProcessing.ClassBalancing",
        "description": "preProcessing.ClassBalancing",
        "peekOfCode": "def balance_classes(X, y):\n    y = np.ravel(y)\n    class_counts = Counter(y)\n    min_class_size = min(class_counts.values())\n    # print(f\"Class distribution before balancing: {class_counts}\")\n    if min_class_size < 2:\n        # print(\"Some classes have fewer than 2 samples. Using RandomOverSampler instead of SMOTE.\")\n        ros = RandomOverSampler(random_state=42)\n        return ros.fit_resample(X, y)\n    k_neighbors = min(5, min_class_size - 1)",
        "detail": "preProcessing.ClassBalancing",
        "documentation": {}
    },
    {
        "label": "bandpass_filter",
        "kind": 2,
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "peekOfCode": "def bandpass_filter(signal, fs, lowcut=0.5, highcut=40):\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    b, a = butter(4, [low, high], btype='band')\n    return filtfilt(b, a, signal)\n# Removes power line interference (typically 50Hz or 60Hz)\ndef notch_filter(signal, fs, freq=50, Q=30):\n    nyq = 0.5 * fs\n    freq = freq / nyq",
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "notch_filter",
        "kind": 2,
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "peekOfCode": "def notch_filter(signal, fs, freq=50, Q=30):\n    nyq = 0.5 * fs\n    freq = freq / nyq\n    b, a = iirnotch(freq, Q)\n    return filtfilt(b, a, signal)\n# Removes baseline wander using a moving average approach\ndef remove_baseline(signal, fs, window_size=0.2):\n    window_samples = int(window_size * fs)\n    baseline = np.convolve(signal, np.ones(window_samples)/window_samples, mode='same')\n    return signal - baseline",
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "remove_baseline",
        "kind": 2,
        "importPath": "preProcessing.Denoise",
        "description": "preProcessing.Denoise",
        "peekOfCode": "def remove_baseline(signal, fs, window_size=0.2):\n    window_samples = int(window_size * fs)\n    baseline = np.convolve(signal, np.ones(window_samples)/window_samples, mode='same')\n    return signal - baseline",
        "detail": "preProcessing.Denoise",
        "documentation": {}
    },
    {
        "label": "extract_waveform_features",
        "kind": 2,
        "importPath": "preProcessing.FeatureExtraction",
        "description": "preProcessing.FeatureExtraction",
        "peekOfCode": "def extract_waveform_features(record_id, data_dir):\n    # 1. Load signal with annotations\n    signal, rpeaks, fs, ann = load_ecg(record_id, data_dir)\n    print(f\"Total annotations: {len(ann.sample)}\")\n    # 2. Denoising\n    signal = bandpass_filter(signal, fs)\n    signal = notch_filter(signal, fs)\n    signal = remove_baseline(signal, fs)\n    # 3. Heartbeat extraction\n    beats, valid_rpeaks = extract_heartbeats(signal, fs, ann.sample)",
        "detail": "preProcessing.FeatureExtraction",
        "documentation": {}
    },
    {
        "label": "get_class_from_symbol",
        "kind": 2,
        "importPath": "preProcessing.Labels",
        "description": "preProcessing.Labels",
        "peekOfCode": "def get_class_from_symbol(symbol):\n    \"\"\"Map beat symbol to class index based on AAMI classes.\"\"\"\n    for class_idx, symbols in AAMI_classes.items():\n        if symbol in symbols:\n            return class_idx\n    # If symbol not found in any class, consider it normal (class 0)\n    return 0\ndef create_labels(rpeaks, annotation):\n    \"\"\"\n    Create multi-class labels for detected R-peaks based on annotation symbols.",
        "detail": "preProcessing.Labels",
        "documentation": {}
    },
    {
        "label": "create_labels",
        "kind": 2,
        "importPath": "preProcessing.Labels",
        "description": "preProcessing.Labels",
        "peekOfCode": "def create_labels(rpeaks, annotation):\n    \"\"\"\n    Create multi-class labels for detected R-peaks based on annotation symbols.\n    Args:\n        rpeaks (np.array): Detected R-peak sample indices\n        annotation (wfdb.Annotation): Annotation object with .sample and .symbol arrays\n    Returns:\n        np.array: Array of class labels for each R-peak\n    \"\"\"\n    labels = []",
        "detail": "preProcessing.Labels",
        "documentation": {}
    },
    {
        "label": "AAMI_classes",
        "kind": 5,
        "importPath": "preProcessing.Labels",
        "description": "preProcessing.Labels",
        "peekOfCode": "AAMI_classes = {\n    0: ['N', 'L', 'R', 'e', 'j'],      \n    1: ['A', 'a', 'J', 'S'],          \n    2: ['V', 'E'],                    \n    3: ['F'],                         \n    4: ['P', '/', 'f', 'u']           \n}\ndef get_class_from_symbol(symbol):\n    \"\"\"Map beat symbol to class index based on AAMI classes.\"\"\"\n    for class_idx, symbols in AAMI_classes.items():",
        "detail": "preProcessing.Labels",
        "documentation": {}
    },
    {
        "label": "load_ecg",
        "kind": 2,
        "importPath": "preProcessing.Load",
        "description": "preProcessing.Load",
        "peekOfCode": "def load_ecg(record_id, data_dir):\n    \"\"\"\n    Load ECG record and return signal, annotations, and sampling frequency\n    Args:\n        record_id: MIT-BIH record number (e.g., '100')\n        data_dir: Path to directory containing the MIT-BIH data\n    Returns:\n        signal: ECG signal (Lead II)\n        rpeaks: Sample indices of R-peaks -> Total beats in  101  record :  [     7     83    396 ... 649004 649372 649751]\n        fs: Sampling frequency (Hz)",
        "detail": "preProcessing.Load",
        "documentation": {}
    },
    {
        "label": "normalize_beats",
        "kind": 2,
        "importPath": "preProcessing.Normalization",
        "description": "preProcessing.Normalization",
        "peekOfCode": "def normalize_beats(beats):\n    \"\"\"Normalize each beat independently\"\"\"\n    return np.array([(beat - np.mean(beat))/np.std(beat) for beat in beats])",
        "detail": "preProcessing.Normalization",
        "documentation": {}
    },
    {
        "label": "extract_heartbeats",
        "kind": 2,
        "importPath": "preProcessing.Segment",
        "description": "preProcessing.Segment",
        "peekOfCode": "def extract_heartbeats(signal, fs, annotation_rpeaks=None, before=0.25, after=0.4, fixed_length=250):\n    \"\"\"\n    Extract fixed-length heartbeats centered at R-peaks\n    Args:\n        signal: ECG signal\n        fs: Sampling frequency (Hz)\n        annotation_rpeaks: Optional pre-annotated R-peaks\n        before: Seconds before R-peak (default 0.25)\n        after: Seconds after R-peak (default 0.4)\n        fixed_length: Target samples per beat (default 250)",
        "detail": "preProcessing.Segment",
        "documentation": {}
    }
]